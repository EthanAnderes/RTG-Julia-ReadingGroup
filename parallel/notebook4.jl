
#' `pmap` 
#' ==================================================
#' A workhorse of parallelization. 
#'
#' We will also discuss WorkerPools and CachingPools 
#' later in this notebook. They are used for avoiding repeated 
#' passing of closures

using Distributed
using LBblocks
addprocs(4)
@everywhere using InteractiveUtils


#%% `pmap` on  functions explicitly declared in Main with `@everywhere`
#%% ---------------------------------------------------------------------

#' Note: explicity delared functions are not shipped over via pmap so they need 
#' to be defined

@everywhere using Statistics

@everywhere function sim(n,μ)
    rand(n) .+ μ
end

@everywhere function est(sim)
    mean(sim)
end

@everywhere function bias(n,μ)
    (bias=est(sim(n,μ)) - μ, id=myid())
end

@everywhere 2 varinfo()

@everywhere 2 bias(10,.5)


@time results = pmap(
    bias,
    fill(10000,10000),
    fill(0.5,10000)
)





#%% Using pmap with anon functions generated by @sblocks are useful for avoiding
#%% against accidentally shipping global constants
#%% --------------------------------------------------------------------------------

#' When using anon functions with pmap, internal variables *are* shipped over 
#' ...but not references to explicity delcared functions in master Main


a = 2.0
const c = 100

f1 = let
    f = function (x,y)
        z = x - y + a + c
        return z
    end
    f
end  
#' ↑ both :a and :c will get defined in workers Main 
#'... and f1 will be slow

f2 = let a=2
    f = function (x,y)
        z = x - y + a + c
        return z
    end
    f
end  
#' ↑ just :c will be defined on worker Main 
#' :a will get wrapped with :f2 and shipped 
#' ... and f2 will be fast since :c will be  global in worker Main

f3 = let a=2, c=c
    f = function (x,y)
        z = x - y + a + c
        return z
    end
    f
end 
#' ↑ both :a and :c will get wrapped with :f3 and shipped 
#' ... it will be fast

f4 = @sblock let a=2, c # this will error if you forget to add a,c2 here
    f = function (x,y)
        z = x - y + a + c
        return z
    end
    f 
end  
#' ↑ same as f3 

@show code_typed(f1, typeof((1, 1.0)));
@show code_typed(f2, typeof((1, 1.0)));
@show code_typed(f3, typeof((1, 1.0)));
@show code_typed(f4, typeof((1, 1.0)));


cwp = CachingPool(workers())

pmap(f4, cwp, 1:5, 2:6);  # run once for compliation
@time pmap(f4, cwp, 1:5, 2:6); #'
@everywhere 2 varinfo() #' nothing in worker Main

pmap(f3, cwp, 1:5, 2:6); # run once for compliation
@time pmap(f3, cwp, 1:5, 2:6); #'
@everywhere 2 varinfo() #' nothing in worker Main

pmap(f2, cwp, 1:5, 2:6);  # run once for compliation
@time pmap(f2, cwp, 1:5, 2:6); #'
@everywhere 2 varinfo() #' c will be defined in worker 2 main

pmap(f1, cwp, 1:5, 2:6); # run once for compliation
@time pmap(f1, cwp, 1:5, 2:6); #'
@everywhere 2 varinfo() #' nothing in worker Main



#%% Worker pools for queing jobs and another call signature of remotecall_fetch
#%% ==================================================
#%%  `remotecall_fetch(f::Function, wp::AbstractWorkerPool, args...; kwargs...)`
#%%
#%%  Useful for dynamic scheduling of jobs

# restart julia ...
using Distributed
using LBblocks
addprocs(5)
@everywhere using InteractiveUtils # so varinfo() works

const b = rand(1000,1000)

wp  = WorkerPool(workers())
cwp = CachingPool(workers())

fsb = @sblock let a=2, b
    function (x,y)
        z = x - y + a + sum(b)
        return (z,myid())
    end
end

#%% remotecall_fetch(fsb, wp, x, y) finds available worker
@time rtn1 = let fsb=fsb, z=typeof(fsb(1.0, 1.0))[]
    for (x,y) in zip(rand(5000), rand(5000))
        push!(z, remotecall_fetch(fsb, wp, x, y))
    end
    z
end

#%% with CachingPool(workers()) fsb is shipped over just once
@time rtn2 = let fsb=fsb, z=typeof(fsb(1.0, 1.0))[]
    for (x,y) in zip(rand(5000), rand(5000))
        push!(z, remotecall_fetch(fsb, cwp, x, y))
    end
    z
end

#%% with CachingPool(workers()) fsb is shipped over just once
@time rtn3 = let fsb=fsb, x=rand(5000), y=rand(5000)
    pmap(fsb, cwp, x, y)
end





